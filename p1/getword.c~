/**
 * Chris Gilardi - 820489339 - cssc0101
 * CS 570 - Professor J. Carroll
 * Program One - Due 9/5/18
 **/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int getword(char* w) {
	int nextchar;
	int index = 0;
	int bool_isnegative = 0; //"Boolean" check for negative (if there is a $)
	int bool_isescaped = 0; // "Boolean" check for if the character should be escaped
	int bool_containednewline = 0;

	// Go through each character of the input (from stdin).
	while(nextchar = getchar()) {
		if(bool_isescaped == 0 && nextchar == '\\') {
			bool_isescaped = 1;
			continue;
		}

                if(bool_isescaped != 0 && ( nextchar != EOF)) {
                        bool_isescaped = 0;			
                } else {

			// Check for spaces and tabs
 			// If there are any, break. This marks the end of the word
			// If it's the first character, just continue, since we have no word yet and we should ignore leading spaces
			if(nextchar == ' ') { 
				if(index == 0) {
					continue;
				}
				break; // this works by itself
			}
			
			if(bool_isnegative == 0 && nextchar == '~' && index == 0) {
				char *homedir = getenv("HOME");
				int i;
				for(i = 0; homedir[i] !='\0'; i++) {
					w[index] = homedir[i];
					index++;
				}
				continue;
		}			
	
			// Check for ';', newline, and EOF
			// If we get one of these after a word has started, put it back so it can be parsed later
			// If they are first, simply set w to a null character.
			// On EOF, set the index to -255 for late4r.
			// TRICKY: The check for bool_isnegative. If it's negative (i.e. $ first), we must close the $ first (and return null) and THEN handle the ;, newline, or EOF.
			if(nextchar == ';' ||  nextchar == '\n' || nextchar == EOF) {
				if(index != 0 || bool_isnegative == 1){
					ungetc(nextchar, stdin);
				} else {
					w[0] = '\0';
					if(nextchar == EOF) {
						index = -255;
					}
				}
				break;
	
			// If we've already encountered a $, set the returned index flag to be negative.
			} else if(nextchar == '$' && bool_isnegative != 1) {
				if(index == 0) {
					bool_isnegative = 1;
					continue;
				}
			} else if(nextchar == '<') {
				if(index != 0) {
					ungetc(nextchar, stdin);
				} else {
					w[0] = '<';
					index++;
					int temp = getchar();
					if(temp == '<') {
						w[1] = '<';
						index++;
					} else {
						ungetc(temp, stdin);
					}
					// Might not need
				}
				break;
			} else if(nextchar == '|') {
				if(index != 0) {
					ungetc(nextchar, stdin);
				}
				break;
			}
		}
		if(nextchar == '\n') {
			bool_containednewline = 1;
			nextchar = NULL;
		}
                w[index] = nextchar;
                index++;
	}
	// Null-terminate to ensure we don't get garbage in the output
	w[index] = '\0';	

	// Turn the returned index negative if we've encountered a '$' before the word.
	if(bool_isnegative == 1) {
		
		// Remove the first '$' from the output.
		w++;
		
		// Make it negative
		index = (index * -1);
	}

	if(bool_containednewline) {
		index--;
	}

	return index;
}
